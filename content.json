{"meta":{"title":"Walden's 自画像","subtitle":"我的身体存在一半理性，一半感性。它们合力扶直我的身体躯壳，以至于二十多年来跌倒还能站起来，继续前行。","description":"Walden's 自画像 | 我的身体存在一半理性，一半感性。它们合力扶直我的身体躯壳，以至于二十多年来跌倒还能站起来，继续前行。","author":"Walden","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"开源和学习计划","slug":"开源和学习计划","date":"2023-09-24T06:36:26.000Z","updated":"2023-09-24T07:08:32.830Z","comments":true,"path":"2023/09/24/开源和学习计划/","link":"","permalink":"http://example.com/2023/09/24/%E5%BC%80%E6%BA%90%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/","excerpt":"","text":"开源计划计划开发一个 React 前端开发相关工具的开源项目，暂时称之为 lumos。 @lumos/uilumos ui 是一套 React UI 组件库。 @lumos/bootstrapReact web 应用的启动范式，并且进行技术收敛和依赖收敛。 @lumos/hooks常用 hooks。 @lumos/cli一些命令行工具。 @lumos/cpus一些常用的工具方法。 @lumos/define-api针对monorepo项目， @lumos/define-api可以提供跨应用可复用的网络请求api定义，比如通过define-api定义出的网络请求api可以同时提供给react应用，vue应用和小程序使用。 @lumos/starter生成项目模板。 学习计划rust计划学习一门低级语言。 tauri-apps想接触桌面端的开发。","categories":[],"tags":[{"name":"学习,开源,成长","slug":"学习-开源-成长","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0-%E5%BC%80%E6%BA%90-%E6%88%90%E9%95%BF/"}]},{"title":"vue组件的高级应用","slug":"vue动态组件和异步组件使用","date":"2022-04-16T03:53:39.000Z","updated":"2022-04-16T05:10:02.499Z","comments":true,"path":"2022/04/16/vue动态组件和异步组件使用/","link":"","permalink":"http://example.com/2022/04/16/vue%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8/","excerpt":"","text":"我们在开发 vue 应用的时候经常需要封装 vue 组件，今天我们就来研究一下关于 vue 组件的一些高级应用，并且简单深入分析一下其实现原理。研究的内容包括： 动态组件 异步组件 指令式组件 动态组件什么是动态组件？简单来说，动态组件就是在运行时根据数据来决定渲染指定组件的一种应用。举例一种情况： &lt;template> &lt;Comp1 v-if=\"compName === 'Comp1'\"/ > &lt;Comp2 v-else-if=\"compName === 'Comp2'\" /> &lt;Comp2 v-else /> &lt;/template> &lt;script> export default &#123; // ... data() &#123; return &#123; compName: \"Comp1\", &#125;; &#125;, &#125;; &lt;/script> 以上便是条件渲染的应用，其可以实现根据运行时数据来进行组件渲染方案的判断。但是很明显，当组件和判断条件很多的时候，就需要在 template 中写一大堆条件渲染的判断，这显然不是可取的方法。 所以，动态组件就出现了，如何使用动态组件呢？ &lt;template> &lt;component :is=\"compName\" /> &lt;/template> &lt;script> // imports ... export default &#123; // ... components: &#123; Comp1, Comp2, Comp3, &#125;, data() &#123; return &#123; compName: \"Comp1\", &#125;; &#125;, &#125;; &lt;/script> 以上便是，vue 动态组件的基本使用。我们要注意，需要被渲染的动态组件，必须是已经注册的组件，可以通过全局注册或者组件内组册。另外，:is不可以写成is，因为动态组件必须符合“动态”的目的，如果组件渲染方案已经明确，那就没有必要使用动态组件，所以在 vue 动态组件中使用is是不允许的。 为什么写成&lt;component :is=&quot;compName&quot; /&gt;这样就可以实现动态组件呢？其实这是 vue 模版语法的语法规定而已，最终实际打包（也可以在运行时）的时候，这段字符会被 vue 的模版编译器（vue-template-compiler）编译成 javascript 代码。我们来看一下，这串字符串会被编译成什么样的 js 代码。 function render() &#123; with (this) &#123; return _c(compName, &#123; tag: \"component\", &#125;); &#125; &#125; 对比一下，明确的组件渲染方案会被解析成这样： // &lt;Comp1 /> function render() &#123; with (this) &#123; return _c(\"Comp1\"); &#125; &#125; 我们暂时不深究上面两段代码的所有含义，我们只需要关注_c(compName, &#123;&#125;)和_c(&#39;Comp1&#39;)。可见 compName 是一个变量而非明确的字符串，所以代码运行时是可以通过数据来决定compName到底是一个什么值，从而实现动态组件的目的。 异步组件","categories":[],"tags":[]},{"title":"记一次关于Webpack的项目经历","slug":"记一次关于Webpack的项目经历","date":"2022-04-11T06:33:01.000Z","updated":"2022-04-12T07:48:20.597Z","comments":true,"path":"2022/04/11/记一次关于Webpack的项目经历/","link":"","permalink":"http://example.com/2022/04/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8EWebpack%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/","excerpt":"","text":"趁着有空把我一次关于 Webpack 的项目经历记录一下，其实这个项目是很早之前就做了的，中间重构过两次，而最后一次，即目前的最新代码也是一年前就完成的，只是一直没闲下心记录下来。 这次项目经历重点是围绕着 webpack 和解决方案的分析与实现，对于技术战五渣的我来说是具有一定的记录价值的。 下面的代码已做完全的脱敏处理，而且内容都是公开可访问，没有任何保密技术，仅仅是解决问题的思路，实现方案设计以及 Webpack 的基本使用而已。本文章仅为记录不为分享，随时可删。 需求我们需要在 App 内做一个完整的关于 App 本身和各个产品的使用帮助，该模块名为帮助中心，这个帮助中心决定采用 Web 的方案实现。 当用户在使用 App 时，App 某些原生页面下方会有一个帮助链接，点击链接会通过 Webview 打开一个网页，网页内容会根据用户当前 App 所属系统（Android/iOS），语言，产品，业务和厂商显示不一样的内容。 而我们目前系统选项有 2 种，语言 10 种，产品 20+种，帮助业务 20+种（比如，设备初始化，网络配置，安装帮助等），3 种厂商。最大的可能性会存在 2 万多个页面内容。 历史方案这里先不做分析，而是列一下项目最初的解决方案。 方案一：Markdown 转 HTML 方案最初是利用 webpack + markdown-loader 的方法，通过只编辑 markdown 文档（只关注内容不关注代码）最后打包生成静态 html 页面的方式进行功能实现的。 最初选用这种方案的时候，页面内容还比较少，使用编辑 markdown 的方案，对内容管理起来非常的直观且方便，甚至还可以把内容的编辑工作转交给需求和营销，开发只负责打包和发布。想法非常美好，但现实非常“残酷”。 因为后来我发现需求和营销并不会写 markdown 文档，而且随着内容越来越多，开发和维护这个帮助中心的工作量指数型暴增。另外，页面的内容样式要求也越来越高，且多变，简单的 markdown 样式已经远远不能满足了。 于是，后来就想到了方案二，但是方案二最后的实现效果自己感到不满意，所以最后没有落地。 方案二：自研线上编辑系统就是自己设计开发一个针对帮助中心的业务系统，可以在系统上可视化的录入内容。为了简化重复或者相似内容的页面的编辑工作，可以通过配置来指定不同页面参数指向同一个页面内容。 然而，想法挺好，但是最后实现出来的效果很差。首先版本管理机制有点复杂，发布和回滚机制不好。版本管理，发布和回滚如此复杂，主要是跟公司的后台服务结构有关，我们的后台业务是多站点全球部署，站点内容同步不太好操作。 另外，页面配置的功能设计的比较凌乱，不够直观，结果就是容易出现缺页错页，页面检索困难的情况。 而且，内容编辑还是不够灵活，工作量并没有降低多少，所以最后这种方案虽然是出了第一版，但是并没有采用。 分析以上就是两个历史解决方案，缺陷非常的明显，于是后来又重构了项目。在说出目前的解决方案前，我们先要分析一下需求。 项目要尽量降低工作量，无论是开发还是后期维护； 具有高度的灵活性，无论是样式灵活性，还是页面 javascript 的灵活性； 页面必须具有原子性，不可过多加载无用的内容或文件，比如无用国际化内容，即便相同语种但是用不到的内容，也尽量不要加载，因为一个国际化文件真的很大； 具有有效的属性检索和内容审核途径； 有效的开发，可调式途径； 后来考虑使用 SSR 或者 SSG 的方案来做，但是因为一些决策和历史原因，没有采用 SSR 的方案，而是采用 webpack + pug 实现自建 SSG 的方案。 最终方案：webpack + pug 实现 SSG关于现成的 SSG 框架其实都不适用于本项目，比如 NuxtJS，NextJS，VuePress，因为它们也都是有预设的生成机制，而这种机制可配置性应该是有限的，考虑到上面分析的第 1、3 点，所以决定自己实现 SSG 机制。 至于模板引擎采用了 pug，原因是 pug 具有简洁的代码编写风格，且具有优秀的布局与组件支持，同时支持页内写编译时的 js 代码。以前也有用过另外两个模板引擎 handlebars 和 ejs。而这次没有使用它们是因为 handlebars 没有很好的布局支持，只有组件支持，而且不支持在页内写编译时的 js 代码；而 ejs 也没有很好的布局支持，虽有组件支持，但是引入方式不太喜欢，虽支持在页内写编译时的 js 代码且灵活度非常高，但是语法比较容易乱，个人看着不太喜欢。 项目基本架构 以上分层结构与目录结构没有直接关系，仅仅是架构设计，而项目的目录采用扁平化的设计，避免无必要的目录嵌套。 Views &amp; Assets 层此层包括了 pages，components，layouts，assets 和 entries 五个部分。 components 和 layouts 都是一些 pug 文件，作为复用的布局和组件。比如： default.pug 是默认的布局文件。 doctype html - const langCode = lang.substr(0, 2); block variables html( lang=langCode === \"zh\" ? (lang === \"zh_CN\" ? \"zh-Hans\" : \"zh-Hant\") : langCode ) head meta(charset='UTF-8') meta(http-equiv='X-UA-Compatible', content='IE=edge') meta( name='viewport', content='width=device-width, initial-scale=1.0, user-scalable=no' ) title #&#123; t(\"common_help_center_page_title\") &#125; body article block top div.content block content contact.pug是公共的组件。 - const phone = t(\"contact_tel\"); - const email = t(\"contact_email\"); - const phoneHtml = `&lt;a href=\"tel:$&#123;phone&#125;\">$&#123;phone&#125;&lt;/a>`; - const emailHtml = `&lt;a href=\"mailto:$&#123;email&#125;\">$&#123;email&#125;&lt;/a>`; - const contactDetailHtml = sprintf(t(\"common_contact_p\"), phoneHtml, emailHtml).replace(/\\n/g, '&lt;br>'); if condition // 伪代码，这里隐藏可能敏感的代码 h3 #&#123; t(\"common_contact_title\") &#125; p !&#123; contactDetailHtml &#125; assets 是存放图片文件的，这些图片可能会被组件，布局，pages 的 tpl.png 和 entries 中的 javascript 使用。 entries 中存放的是被 webpack 打包的 js 和 css 文件，对应 webpack 中的 entries 配置，实际使用如下： // 省略import module.exports = &#123; mode: process.env.NODE_ENV, entry: &#123; main: path.resolve(__dirname, \"..\", \"entries/main.js\"), aegisMountGuide: path.resolve( __dirname, \"..\", \"entries/aegis-mount-guide.js\" ), &#125;, // 省略此后代码 &#125;; pages 目录是整个项目中的核心，此目录下包含了很多文件夹，每个文件夹对应一个页面模板，每个目录包含三个文件，分别是： README.md 与此页面的模版和打包配置的相关说明，提高可维护性（文档永远都是最重要的）； tpl.pug 页面模板； build.config.js 限制 tpl.pug 的适用范围； 举例一个实际的build.config.js。 const &#123; Page, Code, Platform, Language, Corp, &#125; = require(\"../../utils/constraints\"); module.exports = &#123; include: &#123; page: [Page.DEVICE_INIT], code: [Code.SENTRY, Code.AEGIS, Code.CC, Code.XC, Code.X1, Code.X1_OLD], &#125;, exclude: &#123;&#125;, dev: &#123; platform: [Platform.IOS], lang: [Language.zh_CN], &#125;, &#125;; 或者另外一个例子： const &#123; Page, Code &#125; = require(\"../../utils/constraints\"); module.exports = &#123; include: &#123; page: [Page.MOUNT_GUIDE], code: [Code.AEGIS], &#125;, exclude: &#123;&#125;, chunks: [\"aegisMountGuide\"], dev: false, &#125;; 可见，这个 build.config.js 文件主要是为了解决工作量的问题，它可以归纳相同或相似的内容使用相同的tpl.png。 完整的一个config.build.js可配置属性包括： include 定义模板适用的范围，可接受对象或者数组，采用显性覆盖的规则，即不在 include 中显性定义的属性，则采用全量配置，比如 include 中没有显性指定语言适用范围，则默认 10 种语言都采用该模版； exclude 可选配置，补充定义在 include 的过滤结果的排除项，所以 exclude 权重大于 include； ignoreKeys 可选配置，忽略页面属性，使用default代替，比如如果页面不区分产品型号，则可配置ignoreKeys: [&quot;code&quot;]，此配置用于降低页面生成数量； chunks 可选配置，定义该模版独有的 js 代码，接受字符串数组，取值来源于 webpack 中定义的entries； bundle 可选配置，定义是否参与打包，可取 boolean 值； dev 可选配置，定义参与开发时 devServer 的适用范围，是 include 配置的子集，设置这个配置是为了提高开发的热重载的效率。之前不设置此配置，每次修改完一处代码，webpack 都会全量更新，而由于项目页面内容过多，造成页面热更新太慢了； 以上便是 build.config.js 的全部配置说明。一个配置文件仅对应一个tpl.pug，实际的一个 tpl.pug 如下： extends /layouts/default block content - const prefix = \"binding_failure_device\"; h3 #&#123; t(prefix, \"section_1_title\") &#125; ol each item in times(4, (n) => t(prefix, \"section_1_li\", n + 1)) li #&#123; item &#125; h3 #&#123; t(prefix, \"section_2_title\") &#125; p #&#123; t(\"binding_failure_tip\") &#125; ol each item in times(3, (n) => t(prefix, \"section_2_li\", n + 1)) li #&#123; item &#125; - let image = \"\"; - switch (code) &#123; case Code.PIR: image = require('@assets/pir_init_2.png'); break; case Code.DING_DONG: image = require('@assets/dingdong_open.png'); break; case Code.DOOR_SENSOR: image = require('@assets/door_sensor_open.png'); break; case Code.GATEWAY: image = require('@assets/gateway_open.png'); break; &#125; if image p img(src=image) include /components/contact 可以发现以上两个 tpl.pug 的例子使用了一些变量和方法，比如t()，times()，code 和 Code 等，这些方法和变量（形参）都是通过下一层 Generator 注入进来的。 Generator 层Generator 层的工作是负责收集 pages 目录下的所有 build.config.js 并进行解析分析，生成一个页面配置数组，generator 会遍历次数组，组装成一个 htmlWebpackPlugin 的实例数组，根据实际注入所需的参数和方法，最后交由 Webpack 生成文件。 一个 htmlWebpackPlugin 如下： new HtmlWebpackPlugin(&#123; filename: `$&#123;item.page&#125;_$&#123;item.corp&#125;_$&#123;item.lang&#125;_$&#123;item.code&#125;_$&#123;item.platform&#125;.html`, template: exports.getRenderFilePath(configFile), chunks: [...(isDev ? [\"simulator\"] : []), \"main\", ...(config.chunks || [])], chunksSortMode: \"manual\", templateParameters: params, &#125;); 上面代码中的 item 便是经过配置解析器和分析器处理过后的页面配置，通过拼接起来作为页面名称，而 exports.getRenderFilePath(configFile) 是获取配置文件所在目录下的 tpl.pug 的路径，params 便是注入到页面中所需的参数和方法。 params的组装如下： let params = &#123; // t方法获取制定的key内容 t: function (...strings) &#123; //! 这里设置链接符号为\"_\" return t(item.lang, strings.join(\"_\")); &#125;, sprintf, times, // 判断当前页面是否匹配某build.config.js // 试用方法请参考/components/internet-connect-failure.pug isMatch: function (pageParams, config) &#123; //! 这里不许用传入devMode const list = exports.parseConfig(config); for (const key in pageParams) &#123; const value = pageParams[key]; const flag = list.findIndex( (item) => item[key].includes(value) || item[key][0] === \"default\" ) === -1; if (flag) return false; &#125; return true; &#125;, Code, Page, Corp, Platform, Language, ...item, &#125;; 上面的代码的 t() 是由 i18n &amp; locales 提供的，代码如下： const en_US = require(\"../locales/en_US.json\"); const zh_CN = require(\"../locales/zh_CN.json\"); const zh_TW = require(\"../locales/zh_TW.json\"); const de_DE = require(\"../locales/de_DE.json\"); const fr_FR = require(\"../locales/fr_FR.json\"); const it_IT = require(\"../locales/it_IT.json\"); const ja_JP = require(\"../locales/ja_JP.json\"); const ru_RU = require(\"../locales/ru_RU.json\"); const es_ES = require(\"../locales/es_ES.json\"); const pt_PT = require(\"../locales/pt_PT.json\"); const chalk = require(\"chalk\"); const messages = &#123; en_US: &#123; ...zh_CN, ...en_US &#125;, zh_CN: &#123; ...en_US, ...zh_CN &#125;, zh_TW: &#123; ...zh_CN, ...en_US, ...zh_TW &#125;, de_DE: &#123; ...zh_CN, ...en_US, ...de_DE &#125;, fr_FR: &#123; ...zh_CN, ...en_US, ...fr_FR &#125;, it_IT: &#123; ...zh_CN, ...en_US, ...it_IT &#125;, ja_JP: &#123; ...zh_CN, ...en_US, ...ja_JP &#125;, ru_RU: &#123; ...zh_CN, ...en_US, ...ru_RU &#125;, es_ES: &#123; ...zh_CN, ...en_US, ...es_ES &#125;, pt_PT: &#123; ...zh_CN, ...en_US, ...pt_PT &#125;, &#125;; function t(lang, key) &#123; const str = messages[lang][key]; if (!str) &#123; console.log( `$&#123;chalk.bgYellow.white(\"[WARNING]\")&#125; 无法从$&#123;lang&#125;中找到$&#123;key&#125;` ); &#125; return str || \"\"; &#125; module.exports = t; 最后生成的 htmlWebpackPlugin 实例数组会交由 webpack 处理。 webpack 层webpack 的运行我采用了 node interface 的方式去实现，而不是 webpack-cli。 webpack 的配置文件如下： const path = require(\"path\"); const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); const CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\"); const TerserPlugin = require(\"terser-webpack-plugin\"); module.exports = &#123; mode: process.env.NODE_ENV, entry: &#123; main: path.resolve(__dirname, \"..\", \"entries/main.js\"), aegisMountGuide: path.resolve( __dirname, \"..\", \"entries/aegis-mount-guide.js\" ), &#125;, output: &#123; path: path.resolve(__dirname, \"..\", \"dist\"), filename: \"js/[name].js?[chunkhash]\", clean: true, &#125;, resolve: &#123; alias: &#123; \"@assets\": path.resolve(__dirname, \"..\", \"assets\"), &#125;, &#125;, module: &#123; rules: [ &#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: \"babel-loader\", options: &#123; presets: [\"@babel/preset-env\"], &#125;, &#125;, &#125;, &#123; test: /\\.pug$/, use: [ &#123; loader: \"pug-loader\", options: &#123; root: path.resolve(__dirname, \"../\"), &#125;, &#125;, ], &#125;, &#123; test: /\\.(png|jpe?g|gif|svg|webp)(\\?.*)?$/, loader: \"url-loader\", options: &#123; limit: false, esModule: false, name: \"images/[name].[ext]?[hash:7]\", &#125;, &#125;, &#123; test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, loader: \"url-loader\", options: &#123; esModule: false, name: \"media/[name].[ext]?[hash:7]\", &#125;, &#125;, &#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: \"url-loader\", options: &#123; esModule: false, name: \"fonts/[name].[ext]?[hash:7]\", &#125;, &#125;, &#123; test: /\\.s[ac]ss$/i, use: [MiniCssExtractPlugin.loader, \"css-loader\", \"sass-loader\"], &#125;, ], &#125;, optimization: &#123; minimize: true, minimizer: [new TerserPlugin(), new CssMinimizerPlugin()], &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: \"css/[name].css?[contenthash]\", chunkFilename: \"css/[id].css?[contenthash]\", &#125;), ], &#125;; build 执行文件如下： /** * Created Date: Thursday, September 2nd 2021, 1:56:14 pm * Author: Walden * Description: webpack 打包的数据构建和流程 * ----- * Last Modified: Sat Sep 18 2021 * Modified By: Walden */ const chalk = require(\"chalk\"); const webpack = require(\"webpack\"); const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); const ProgressBar = require(\"progress\"); const &#123; generateHtmlWebpackPlugins &#125; = require(\"../utils\"); const webpackConfig = require(\"./webpack.config\"); const htmlWebpackPlugins = generateHtmlWebpackPlugins(process.env.NODE_ENV); webpackConfig.plugins.push(...htmlWebpackPlugins); var bar = new ProgressBar(\"(:percent) [:bar] (:current/:total)\", &#123; total: htmlWebpackPlugins.length, clear: true, callback: () => console.log(chalk.bold.green(\"页面生成完成\")), &#125;); const compiler = webpack(webpackConfig); compiler.hooks.compilation.tap(\"PageBuildProgressPlugin\", (compilation) => &#123; HtmlWebpackPlugin.getHooks(compilation).beforeAssetTagGeneration.tap( \"PageBuildProgressPlugin\", () => bar.tick() ); &#125;); compiler.run((err, stats) => &#123; if (err) &#123; console.error(err); return; &#125; console.log( stats.toString(&#123; chunks: false, chunkModules: false, modules: false, moduleAssets: false, children: false, colors: true, assets: false, groupAssetsByChunk: false, warningsCount: false, warnings: false, preset: \"minimal\", &#125;) ); &#125;); 为了提高打包体验，自定义了打包进度功能。 devServer 的代码如下： /** * Created Date: Wednesday, September 15th 2021, 11:21:31 am * Author: Walden * Description: server.js * ----- * Last Modified: Sat Sep 18 2021 * Modified By: Walden */ const webpack = require(\"webpack\"); const WebpackDevServer = require(\"webpack-dev-server\"); const webpackConfig = require(\"./webpack.config\"); const &#123; generateHtmlWebpackPlugins &#125; = require(\"../utils\"); const htmlWebpackPlugins = generateHtmlWebpackPlugins(process.env.NODE_ENV); webpackConfig.plugins.push(...htmlWebpackPlugins); const compiler = webpack(webpackConfig); const devServerOptions = &#123; hot: false, liveReload: true &#125;; const server = new WebpackDevServer(devServerOptions, compiler); server.startCallback(() => &#123; console.log(\"Starting server on http://localhost:8080\"); &#125;); package.json 执行指令如下： &#123; \"scripts\": &#123; \"dev\": \"cross-env NODE_ENV=development node ./build/server.js\", \"build\": \"cross-env NODE_ENV=production node ./build/index.js\", \"build:docs\": \"webpack build --config ./build-docs/webpack.config.js --mode production\", \"dev:docs\": \"webpack serve --config ./build-docs/webpack.config.js --mode development\" &#125; &#125; 下面是实际打包的截图： 通过上图可见，实际的开发中只需维护 30+个模板就可以生成 5000+个页面，而且页面的内容都是全静态的，无需 javascript 运行渲染。 以下是实际生成的 html（实际已压缩，这里为了方便阅读，我格式化了）： &lt;!DOCTYPE html> &lt;html lang=\"de\"> &lt;head> &lt;meta charset=\"UTF-8\" /> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /> &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,user-scalable=no\" /> &lt;title>Hilfe&lt;/title> &lt;script defer=\"defer\" src=\"js/main.js?0e77711ce159ff038f7d\">&lt;/script> &lt;link href=\"css/main.css?4edb539dfee4b9ea73b2\" rel=\"stylesheet\" /> &lt;/head> &lt;body> &lt;article> &lt;div class=\"content\"> &lt;h3>Einstellung des Zusatzgeräts&lt;/h3> &lt;ol> &lt;li> Stellen Sie sicher, dass Ihr Handy mit dem Internet verbunden ist. &lt;/li> &lt;li> Setzen Sie das Zubehörgerät zurück. Sie können diesen Schritt überspringen, wenn das Gerät bereits zurückgesetzt wurde. &lt;/li> &lt;li> Stellen Sie sicher, dass ein Hub-fähiges Gerät bereits konfiguriert wurde. &lt;/li> &lt;li>Folgen Sie den Anweisungen zum Hinzufügen des Zusatzgeräts.&lt;/li> &lt;/ol> &lt;h3>Gerät kann nicht hinzugefügt werden?&lt;/h3> &lt;p>Bitte beachten Sie die folgenden Schritte:&lt;/p> &lt;ol> &lt;li> Prüfen Sie, ob das Hub-fähige Gerät eingerichtet und online ist. &lt;/li> &lt;li>Prüfen Sie, ob das Zusatzgerät mit Strom versorgt wird.&lt;/li> &lt;li>Prüfen Sie, ob die Taste des Zusatzgeräts funktioniert.&lt;/li> &lt;/ol> &lt;p>&lt;img src=\"images/dingdong_open.png?ce47183\" />&lt;/p> &lt;/div> &lt;/article> &lt;/body> &lt;/html> 总结其实项目还配有一个审核系统，同样也是 SSG 实现的，原理差不多，这里就不记录了。关于这个审核系统是我在日常维护中，发现需求和测试不方便全面核对内容，所以我就自主的搞了一个系统出来，效果非常好。 以上便是关于我一次 Webpack 的项目经历的所有内容，虽然技术并不难，但是也是充满了挑战的，非常享受这种通过重构项目而让项目变得更加好的感觉。","categories":[{"name":"理性","slug":"理性","permalink":"http://example.com/categories/%E7%90%86%E6%80%A7/"}],"tags":[{"name":"项目经历,webpack","slug":"项目经历-webpack","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86-webpack/"}]},{"title":"《影帝的公主》观后感","slug":"影帝的公主观后感","date":"2022-04-09T11:53:18.000Z","updated":"2022-04-10T02:03:13.517Z","comments":true,"path":"2022/04/09/影帝的公主观后感/","link":"","permalink":"http://example.com/2022/04/09/%E5%BD%B1%E5%B8%9D%E7%9A%84%E5%85%AC%E4%B8%BB%E8%A7%82%E5%90%8E%E6%84%9F/","excerpt":"","text":"快乐高兴的情感多如流水般在心间轻淌而过，而凄美有遗憾的总能长久地萦绕在心头，久久不能释怀。 这段时间入迷地看了两部剧，一部是前面说到的《尚食》，而这次是《影帝的公主》。关于这次看的《影帝的公主》，它让我内心久久不能平复，遂写一篇观后感，以表感怀。 电视剧大概讲诉了这么一个故事。穆廷州是一个沉浸影视事业的影帝，他情商低，为人高冷，没有恋爱经验。有一天他和一位演艺圈新人女演员明薇合作演绎一部名叫《一代首傅》的电视剧。穆廷州由于入戏太深，不甘愿接受《一代首傅》中遗憾的结局，在杀青后的一次车祸意外中失去了所有现代记忆，而苏醒了《一代首傅》中男主角太傅的记忆，或者说是人格。此时的穆廷州对所有人包括好友和亲人都是陌生排斥的，除了在剧中饰演公主的明薇。为了帮助穆廷州恢复记忆，明薇同意陪伴在穆廷州身旁，引导他恢复记忆。但是，在这个恢复记忆过程，明薇却因为太傅的痴情而对太傅产生了刻骨铭心的情愫，深陷其中，无法自拔。明薇深刻知道这个爱情可能会在太傅恢复了穆廷州的记忆后而走向悲剧，但是她依旧同意了太傅的求娶，爱的义无反顾。果然，就在他们成亲的当天，太傅“死了”，穆廷州恢复了记忆，却忘记了所有关于《一代首傅》和失忆后一年里的所有事情，丝毫不剩，全忘了。此刻穆廷州对明薇的感觉只有陌生，而这种陌生感让明薇认知到一个事实，她男朋友死了。穆廷州为人正直，但是情商低，他想在物质方面给予明薇补偿，但是结果适得其反，明薇认为穆廷州的这种行为是对她和太傅之间忠贞的爱情的亵渎。明薇用了很久时间才能从悲伤中走出来，她把与太傅相处的日子的记忆珍藏在心中，恢复了正常的拍摄工作。穆廷州偶尔能够通过太傅在一年里留下的生活痕迹中了解到了明薇和太傅的过往，并且在新剧梁祝中，再一次和明薇合作拍摄。在长久的拍摄过程中，穆廷州发现他再次爱上了明薇，这不是受太傅的记忆影响，而是无论穆廷州和太傅爱上明薇都是遵随内心深处的感情，因为他们仅仅是一个人，是同一颗心在跳动。最后穆廷州努力追回了明薇，守得云开见月明，有情人终成眷属。在故事的大结局，穆廷州和明薇举行了古式的婚礼，弥补了《一代首傅》的遗憾，也为他们的故事给出一个美好的结局。 整部戏把故事诠释的非常好，所有所有的演员的演技都非常精湛，非常入戏。唯一不足的地方可能就是穆廷州恢复记忆后又爱上明薇这个过程处理的略微有点马虎，虽然他们爱情重圆是必然的结果，但是个人觉得《梁祝》的合作过程可以更详细，更动人的，我个人本来就非常喜欢梁祝这个故事。但是总体来说这部戏都是非常不错的。 就如最开头所写的一样，凄美，有遗憾的情感可以在我心头萦绕很久很久。无论《一代首傅》还是现实中的太傅和明薇的感情，都是充满了遗憾，牵动着我的内心，以至于我不得不写下这篇读后感来慰藉内心。感动的地方很多很多，台词设计也非常棒，而其中印象最深就是穆廷州恢复记忆后想在物质方面补偿明薇，这个行为在明薇眼中是对她的感情和付出的嘲笑，于是明薇的台词是： 我跟太傅真情实意谈的那场恋爱，在你这儿，就成了赠送给观众的番外，我跟太傅谈的都是真感情，而你口口声声跟我谈的都是金钱。 这一句话，可以看出明薇对和太傅之间的那段爱情到底有多么多么的珍视，以至于不允许丝毫玷污。面对一个跟自己相爱的人相同的一副身躯，却遭受他利用金钱来衡量自己珍视万分的爱情的这种行为，我想此时此刻的明薇内心已经死透了，没有了任何妄想和所谓的“可能”，她实实在在的接受了男友去世这个事实。这一刻我真的控制不住自己泪腺的开关了。 太傅和明薇之间短暂的爱情就是我心中认为的遗憾，他们没有完成的婚礼就是一个圆满中的缺，即便最后穆廷州与明薇还是在一起了，但是总觉穆廷州并非太傅，毕竟他们的刘海不一样，那个深爱公主的太傅可能真的离开了，如果丰富《梁祝》的剧情可能就能很好的减轻这种遗憾。 我非常敬佩和喜欢太傅和明薇那种为了爱的义无反顾，只要认定对方是自己珍视的人，便可用生命去争取和守护。这里想到《尚食》中子衿的一句话，我觉得用在这里非常贴切。 亦余心之所向矣，虽九死其犹不悔。 其实剧中除了男女爱情值得敬佩和喜爱之外，还有友爱和家爱都非常的值得细品。虽然，我不能从这部戏中提炼出多少道理，但是仅仅一个“爱”就值得我长久铭记。 人立于世，不能没有爱，无论去爱还是被爱，都是一个人应有的义务和权利。爱很可能就是一个人书写完一生最大的动力。 感谢《影帝的公主》的所有参与者！","categories":[{"name":"感性","slug":"感性","permalink":"http://example.com/categories/%E6%84%9F%E6%80%A7/"}],"tags":[]},{"title":"手撸 Promise 的思路分享","slug":"从零实现Promise","date":"2022-04-07T05:58:34.000Z","updated":"2022-04-07T10:09:37.580Z","comments":true,"path":"2022/04/07/从零实现Promise/","link":"","permalink":"http://example.com/2022/04/07/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Promise/","excerpt":"","text":"前段时间在几个大牛作者的微信公众号上都看到了手撸 Promise 的文章，当时就觉得挺有意思，想自己也手撸一遍顺便检验一下基础，所以我当时没有看大佬们的代码实现，怕产生潜意识。正好这段时间比较空闲，于是撸了两个版本。第一版（v1）是第一次跑通用例的版本，很粗糙；而第二版（v2）是在第一版的基础上并结合官方测试用例的测试思路优化过后的版本，是我个人比较满意的版本，它可能不是最优版本（跑完 872 条用例耗时 16s），但应该是比较直观易懂的版本。 这里贴出测试结果： ...省略前面内容 The value is &#96;1&#96; with &#96;Number.prototype&#96; modified to have a &#96;then&#96; method ✓ already-fulfilled ✓ immediately-fulfilled ✓ eventually-fulfilled ✓ already-rejected ✓ immediately-rejected ✓ eventually-rejected 872 passing (16s) 本文主要想跟大家分享一下实现思路，希望能够对感兴趣但没有思路的小伙伴们有帮助。 实现思路Promise 是一种机制，形象（自以为形象）的做一个比喻，Promise 机制就好像一个导水装置。这个导水装置有几个组成部分： 有一个入水口 T； 有一个储水管道； 有两个出水口，分别是 F 出水口，和 R 出水口； 有两个拉闸 FHook 拉闸 和 RHook 和拉闸，分别控制两个出水口打开； 导水装置的工作机制： 出水口最开始状态都是关闭的，只能通过两个拉闸控制打开； 出水口永远最多只能打开一个，且开了就无法关闭，即 FHook 和 RHook 只能被拉一次（不是分别拉一次，是总共一次），多拉无效； 入水口 T 可以在任意时候注水； 注水时，如果出口没有被打开，水会存储在储水管道内，直到有一个门被打开； 注水时，如果出水口已开，水会直接导出，无需在储水管道内存储； 最先注入的水会最先被导出，导出的水不允许回收； 上面的比喻是个人总结，仅仅是为了更好的帮助大家初步理解，但并不能覆盖到 Promise 所有的机制，所以到真正实现的时候，希望大家不要被这个比喻局限。下面我们尝试把原生的 Promise 代入到导水装置进行组成拆分。 // 新建了一个`promise`，可理解为是一个导水装置 // 初始状态，出水口都是关闭的，我们用 `pending` 来表示该状态 const promise = new Promise(function (resolve, reject) &#123; // `resolve` 就是 F 出水口的拉闸 FHook // `reject` 就是 R 出水口的拉闸 RHook //! 两个拉闸都是导水装置的固有组成部分，它们不能代表此时装置的状态 //! 只有真正的拉动拉闸（即方法调用），装置的状态才会改变 // 我们设置延时，1s 后再去拉闸 setTimeout(function () &#123; if (condition) &#123; // 这里是 `condition` 是伪代码，模拟判断条件 // `resolve()` 表示拉动了 FHook 拉闸，F 出水口会被打开 // 我们用 `fulfilled` 来表示 F 出水口已被打开 resolve(); // 第二次的拉闸动作是无效行为 resolve(); // 此时的 R 出水口不可以被打开了，所以拉 RHook 也是一个无效行为 reject(); &#125; else &#123; // 如果不满足 `condition` 条件，则会打开 R 出水口 // 我们用 `rejected` 来表示 R 出水口已被打开 reject(); // 同样，重复或其他拉闸操作都是无效行为 reject(); resolve(); &#125; &#125;, 1000); &#125;); // `promise.then` 就是导水装置的唯一入水口 T // 只能通过它来进行注水 // 而 `onFulfilled` 和 `onRejected` 合起来就是一个单位的水（暂时这么理解） // 由于此时出水口还没有被打开（1s 后才拉闸），所以注入的水会被存储起来 promise.then( function onFulfilled() &#123; // do something when promise fulfilled &#125;, function onRejected() &#123; // do something when promise rejected &#125; ); // 我们可以在任何时候注水 // 此单位的也会被存储 promise.then( function onFulfilled() &#123;&#125;, function onRejected() &#123;&#125; ); setTimeout(function () &#123; // 我们可以在任何时候注水 // 此单位的也会被存储 promise.then( function onFulfilled() &#123;&#125;, function onRejected() &#123;&#125; ); &#125;, 300); setTimeout(function () &#123; // 我们可以在任何时候注水 // 此时出水口已被打开（2s 前被打开了），此单位的水会直接被导出，无需存储 promise.then( function onFulfilled() &#123;&#125;, function onRejected() &#123;&#125; ); &#125;, 3000); 初步实现经过上面的分析，我们现一起简单地用代码来实现这个“导水装置”。 // 定义“装置”的三个状态常量 // 所有出口关闭 const PENDING = \"pending\"; // F 出水口已打开 const FULFILLED = \"fulfilled\"; // R 出水口已打开 const REJECTED = \"rejected\"; // 这里采用 Function-Type 来实现，当然也可以用Class-Type function EasyPromise(func) &#123; // func 是必须的，否则无法“安装拉闸” if (typeof func !== \"function\") &#123; throw new TypeError(\"promise resolver must be a function\"); &#125; // 安装拉闸 func(_resolveHook, _rejectHook); // 初始状态 let _status = PENDING; // 这是储水管道 let _awaitQueue = []; // 入水口 this.then = function (onFulfilled, onRejected) &#123; if (_status === PENDING) &#123; // 进行储水操作 // TODO: 实现储水逻辑 _awaitQueue.push(&#123;&#125;); &#125; else if (_status === FULFILLED) &#123; // 直接导出 // TODO: 实现 F 出水口导水逻辑 &#125; else if (_status === REJECTED) &#123; // 直接导出 // TODO: 实现 R 出水口导水逻辑 &#125; &#125;; // F 出水口拉闸 FHook function _resolveHook() &#123; // 忽略重复拉闸的无效行为 if (_status === PENDING) &#123; // 打开 F 出水口 _status = FULFILLED; // 导出管道中的水 _awaitQueue.splice(0).forEach(function () &#123; // do something &#125;); &#125; &#125; // R 出水口拉闸 RHook function _rejectHook() &#123; // 忽略重复拉闸的无效行为 if (_status === PENDING) &#123; // 打开 R 出水口 _status = REJECTED; // 导出管道中的水 _awaitQueue.splice(0).forEach(function () &#123; // do something &#125;); &#125; &#125; &#125; 以上便是这个“导水装置”的大概长得样子，当然这不是 Promise 的最终的实现，这仅仅是一个“骨架”而已。要实现正真的 Promise 机制需要补充 Promise 的机制说明，我们可以阅读 Promise A+规范 来补充，中文版这可以阅读这位大佬的 译文。 以上就是本人的实现思路，为了能够让对 Promise 的原理感兴趣的伙伴们能够快速找到实现思路，我大胆的给出一个“形象”的比喻，希望能够帮助到大家，而没有被误导到。 Promise 完整实现以下是本人手撸 Promise 机制的完整实现。 const PENDING = \"pending\"; const FULFILLED = \"fulfilled\"; const REJECTED = \"rejected\"; function EasyPromise(func) &#123; if (typeof func !== \"function\") &#123; throw new TypeError(\"promise resolver must be a function\"); &#125; func(_resolveHook, _rejectHook); let _status = PENDING; let _awaitQueue = []; let _value; let _reason; this.then = function (onFulfilled, onRejected) &#123; const promise2 = new EasyPromise(function (resolve, reject) &#123; if (_status === PENDING) &#123; _awaitQueue.push(&#123; resolve: resolveFunc, reject: rejectFunc, &#125;); &#125; else if (_status === FULFILLED) &#123; resolveFunc(_value); &#125; else if (_status === REJECTED) &#123; rejectFunc(_reason); &#125; function resolveFunc(v) &#123; setTimeout(function () &#123; if (typeof onFulfilled === \"function\") &#123; try &#123; const x = onFulfilled(v); _resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125; else &#123; resolve(v); &#125; &#125;, 0); &#125; function rejectFunc(r) &#123; setTimeout(function () &#123; if (typeof onRejected === \"function\") &#123; try &#123; const x = onRejected(r); _resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125; else &#123; reject(r); &#125; &#125;, 0); &#125; &#125;); return promise2; &#125;; function _resolveHook(v) &#123; if (_status === PENDING) &#123; _value = v; _status = FULFILLED; _awaitQueue.splice(0).forEach(function (&#123; resolve &#125;) &#123; resolve(v); &#125;); &#125; &#125; function _rejectHook(r) &#123; if (_status === PENDING) &#123; _reason = r; _status = REJECTED; _awaitQueue.splice(0).forEach(function (&#123; reject &#125;) &#123; reject(r); &#125;); &#125; &#125; function _resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; reject( new TypeError(\"The `promise` and `x` cannot refer to the same object.\") ); &#125; if (x &amp;&amp; (typeof x === \"object\" || typeof x === \"function\")) &#123; let lock = false; try &#123; const then = x.then; if (typeof then === \"function\") &#123; then.call( x, function (y) &#123; !lock &amp;&amp; ((lock = true), _resolvePromise(promise2, y, resolve, reject)); &#125;, function (r) &#123; !lock &amp;&amp; ((lock = true), reject(r)); &#125; ); &#125; else &#123; !lock &amp;&amp; ((lock = true), resolve(x)); &#125; &#125; catch (e) &#123; !lock &amp;&amp; ((lock = true), reject(e)); &#125; &#125; else &#123; resolve(x); &#125; &#125; &#125;","categories":[{"name":"理性","slug":"理性","permalink":"http://example.com/categories/%E7%90%86%E6%80%A7/"}],"tags":[{"name":"Javascript,Promise","slug":"Javascript-Promise","permalink":"http://example.com/tags/Javascript-Promise/"}]},{"title":"宋小宝发财日记观后感","slug":"宋小宝发财日记观后感","date":"2021-05-22T13:22:18.000Z","updated":"2022-03-31T02:07:34.201Z","comments":true,"path":"2021/05/22/宋小宝发财日记观后感/","link":"","permalink":"http://example.com/2021/05/22/%E5%AE%8B%E5%B0%8F%E5%AE%9D%E5%8F%91%E8%B4%A2%E6%97%A5%E8%AE%B0%E8%A7%82%E5%90%8E%E6%84%9F/","excerpt":"","text":"电影讲述了一个名字叫宋小宝的东北黑小伙跟随他的好兄弟（江湖人称二哥）到深圳打拼，一股热血就冲着发财。然而，他俩哥们到了大城市，因为没有文化，工作找不到，也没有地方住，风餐露宿，日子都只能在天桥底下度过。“发财”距离他们感觉非常遥远。但是小宝天天都在他的发财日记中记录着他的发财历程，嘴角都是挂着满足。 一天早上，小宝醒来睁开眼睛，发现身边躺着似乎还未满月的婴儿，是弃婴。这回，小宝和二哥这道这是摊上麻烦了。于是他们多次计划找一个地方把婴儿给丢下，看看有没有好心人收留。但是善良的小宝不忍心，就又捡了回来。他俩就这么带着孩子，二哥外出找吃，小宝带孩子。 直到有一天，这哥俩在公园的小湖边，救了一个满头白发老爷爷。随后老爷爷了解到小宝的情况，并且为了感恩就允许他俩住在了老爷爷的家里。碰巧老爷爷这里同样也住着一个离异的女人，叫做马露。由于一些误解，马露对小宝他俩稍有芥蒂。 有了落脚的地方，日子算稳定些。小宝这时候才给小孩子取名为天意，他认为这一切的相遇和经历都是上天安排，小宝嘴边依旧带着熟悉的满足的笑容。 此后，小宝就一边照顾着天意，一边边日复一日的找工作，做工作，换工作，再找工作。日子虽然过的很累，工作也很苦，但是淳朴的小宝并没有埋怨过生活一丝一毫。马露开始抛开对小宝的成见，他俩的关系稍稍缓和了。天意逐渐长大后，他叫小宝做爸爸，小宝为此感到所有努力都是值得的。 天意到了该上学的年纪，小宝为了让天意能够上学，非常努力的工作，什么苦的，累的，危险的工作都做。而长大的天意意识到自己妈妈不在身边这一回事，逐渐感到自卑，对别人的眼光敏感，更在意父亲的感受和渴望父亲的多陪伴。然后努力工作的小宝却没有留意到这一点。天意因此着感到非常孤独，一直没有妈妈的他，让他心思非常敏感，学校的孩子也经常欺负他。就这样，天意越长大越叛逆，内心也越是责怪小宝。 老爷爷越来越老，平时全靠小宝细心的照顾着。老爷爷眼看着，眼前这个跟自己毫无半点血缘关系的黑小伙，任劳任怨的照顾自己，眼里仿佛泛着泪光（也可能是我的泪光）。岁月不饶人，老爷爷安详的离开了人世。天意也就失去了疼爱他的爷爷了。 这屋就剩小宝和马露了，二哥常出去“发财”，很早就不住在这里，长大的天意时常跟社会的小混混在一起，很少回家。一晚，小宝发现隔壁马露房子里起大火，连忙生死不顾的跑进去救人，险些丧生火中。经过这件事情，两人就这么在一起了。但是天意误以为小宝是为了马露而抛弃他妈妈，冷嘲热讽的话语，让小宝一气之下，把天意赶走了。走了的还有马露。 这个时候的小宝才感觉到痛苦，仿佛失去了所有。 他的二哥回来了，这位同苦共难的好兄弟对他还是依旧的不离不弃，有困难了，回来找小宝，发财了也回来找小宝。好兄弟有困难不会羞于开口，从来都是不离不弃（人生难得一知己，我太酸了）。 后来天意无意间得到了小宝的那本发财日记，日记里面，没有记载怎么发财，怎么赚钱，记载的都是平平淡淡的日子，怎么抚养天意，怎么陪伴孩子的点点滴滴。天意这才了解到全部事情的经过，才知道自己深深的误解了小宝，于是拼命的赶回去。 这个时候，小宝因为被天意借钱的债主找上门，意外被一棍爆头，鲜血淋漓，二哥背着他到医院，这个时候天意才赶到。 幸好，性命保住了。 大难不死必有后福，孩子解除了误解，马露也回到身边，确定了关系，好兄弟一如既往的不离不弃。 一个圆满的结局！！ 观后感触故事让人感动的地方很多，比如天意和小宝，小宝和老爷爷之间没有血缘关系但是依旧真诚的爱，兄弟之间不离不弃的情感，小宝善良积极向上的人生态度等等。 但是然我感受最深的还是那本发财日记，电影名字就叫做发财日记，以此为题并有深意。发财日记里面，记录的并不是什么赚钱的东西，而是记录着一个人，怎么面对生活，怎么积极向上，怎么对待身边的人和事，怎么给予别人爱，和最后怎么成就生活中的爱和幸福。这些爱和幸福并不是物质上的钱财，但是这些东西却是人生中最宝贵的财富。 发财发财，正有此意！！！","categories":[{"name":"感性","slug":"感性","permalink":"http://example.com/categories/%E6%84%9F%E6%80%A7/"}],"tags":[{"name":"情感,观后感","slug":"情感-观后感","permalink":"http://example.com/tags/%E6%83%85%E6%84%9F-%E8%A7%82%E5%90%8E%E6%84%9F/"}]},{"title":"javascript中可缺省的分号","slug":"javascript中可缺省的分号","date":"2021-04-17T05:02:26.000Z","updated":"2022-03-23T09:09:14.322Z","comments":true,"path":"2021/04/17/javascript中可缺省的分号/","link":"","permalink":"http://example.com/2021/04/17/javascript%E4%B8%AD%E5%8F%AF%E7%BC%BA%E7%9C%81%E7%9A%84%E5%88%86%E5%8F%B7/","excerpt":"","text":"写 javascript 的都知道，代码中的分号(;)很多时候都可以省略不写的，原因是 javascript 的解析器能够自动的分隔语句。 例如，如果两条语句分别在两行，通常分号是可以被省略的，或者一条语句的接下来是右花括号 }，那么这里的分号也可以省略的。但是有些情况下的分号是必须的，比如如下代码： a = 3; // 这里的分号可以省略 b = 4; // 这里的分号可以省略 c = 3; d = 4; // 这里的第一个分号是必须的 注意，javascript 中并不是每一次的换行都会被当作分号，而是在不隐式的添加分号就无法解析代码的时候，才会加上分号，否则不会自动添加分号。例如，一下代码： let a; a = 3; console.log(a); javascript 解析器会将代码理解为： let a; a = 3; console.log(a); javascript 解析器在没有显性的分号时，会尽量的解析更长的代码，直至无法正确解析时，才会隐形的添加分号。 因为如上原因，那么就会造成以下情况： let y = x + f(a + b).toString(); 程序员的本意可能时，这里是两个语句，但是 javascript 会理解为 let y = x + f(a + b).toString(); // 解析器会尽可能的理解更长的语句 以上的这种情况，程序员的真实意图与 javascript 解析器解析出来的结果完全不一致，这种情况的问题，若果不注意，是很难发现的。 所以，有些情况下就会出现防御性的分号，还用上一个例子演示。 let y = x + f; (a + b).toString(); // 这里的分号是一个防御性的分号，通常会出现在()或[]开头的语句中，比如;[1,2,3].join(',') 上面说到，javascript 会尽可能的理解更长的语句，但是涉及到 return，throw，yield，break 和 continue 语句时，则不然，若以上语句后面没有显性的分号且跟着换行符，解析器则会自动分隔语句，例如： return; true; javascript 理解为 return; true; 这意味着，一定不能在 return，break 或 continue 等关键字后面的表达式之间加入换行符。","categories":[{"name":"理性","slug":"理性","permalink":"http://example.com/categories/%E7%90%86%E6%80%A7/"}],"tags":[{"name":"javascript,大犀牛学习日记","slug":"javascript-大犀牛学习日记","permalink":"http://example.com/tags/javascript-%E5%A4%A7%E7%8A%80%E7%89%9B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"}]},{"title":"javascript中字符串的大小比较","slug":"javascript中字符串的大小比较","date":"2021-04-17T04:04:32.000Z","updated":"2022-03-23T09:09:26.301Z","comments":true,"path":"2021/04/17/javascript中字符串的大小比较/","link":"","permalink":"http://example.com/2021/04/17/javascript%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83/","excerpt":"","text":"\"two\" > \"three\" // => true 按照ASCII码表进行比较，从小到大顺序：0-9A-Za-z \"a\" > \"99999999999999999\" // => true 不论长度 无论长度, 从左侧开始比较。","categories":[{"name":"理性","slug":"理性","permalink":"http://example.com/categories/%E7%90%86%E6%80%A7/"}],"tags":[{"name":"javascript,大犀牛学习日记","slug":"javascript-大犀牛学习日记","permalink":"http://example.com/tags/javascript-%E5%A4%A7%E7%8A%80%E7%89%9B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"}]},{"title":"温故知新，两个月啃完“大犀牛”","slug":"立博为证，两个月啃完“大犀牛”","date":"2021-04-16T02:03:57.000Z","updated":"2022-04-11T06:32:10.984Z","comments":true,"path":"2021/04/16/立博为证，两个月啃完“大犀牛”/","link":"","permalink":"http://example.com/2021/04/16/%E7%AB%8B%E5%8D%9A%E4%B8%BA%E8%AF%81%EF%BC%8C%E4%B8%A4%E4%B8%AA%E6%9C%88%E5%95%83%E5%AE%8C%E2%80%9C%E5%A4%A7%E7%8A%80%E7%89%9B%E2%80%9D/","excerpt":"","text":"万丈高楼平地起，需盖高楼，必须要夯实地基，地基不稳，高楼也就塌了。工作上也是一个道理，无论什么行业，若想能够在行业内走得远，站得高，就必须有一个牢固的基础。业务思维固然重要，但是一切都需要建立在基础上。 所以，就在刚刚，入手了一本 Javascript 大犀牛（第七版），计划能在两个月内啃完这本书，扫盲或者温故知新。每天在博客上总结记录一下学习内容。","categories":[{"name":"感性","slug":"感性","permalink":"http://example.com/categories/%E6%84%9F%E6%80%A7/"}],"tags":[]},{"title":"vue组件间通讯","slug":"vue组件间通讯","date":"2017-09-13T03:40:51.000Z","updated":"2022-04-15T06:27:29.411Z","comments":true,"path":"2017/09/13/vue组件间通讯/","link":"","permalink":"http://example.com/2017/09/13/vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E8%AE%AF/","excerpt":"","text":"本文依旧是对 Vue 的基本使用的研究，不会过深的探究其原理。今天研究的内容是 Vue 组件间的通讯方式。 其实能够实现组件间通讯的形式有很多，这里列出常用的几种。 方式一：props父组件通过以下方式向子组件传递数据。 &lt;ChildComp :count=\"count\" /> 子组件通过 props 接受父组件的数据。 &lt;script> export default &#123; // ... props: &#123; count: &#123; type: Number, required: true, &#125;, &#125;, // ... &#125;; &lt;/script> props 方式是由 vue 的响应式机制驱动的，而其响应式机制的实现是依靠原生 javascript api Object.defineProperty 代理数据模型的属性的 getter 和 setter 方法实现的，其中的原理与代理模式相似，这里不做详细的研究。 方式二：组件事件监听与$emit父组件通过@符或者v-on:来监听子组件的事件。 &lt;template> &lt;ChildComp @cry=\"onChildCry\" /> &lt;/template> &lt;script> export default &#123; // ... methods: &#123; onChildCry() &#123; // do something &#125;, &#125;, &#125;; &lt;/script> 子组件通过 $emit api 把指定事件抛给父组件。 &lt;script> export default &#123; mounted() &#123; // when the child is hungry if (isHungry) &#123; this.$emit(\"cry\"); &#125; &#125;, &#125;; &lt;/script> 这种方式的表现形式与 dom0 级事件监听很类似，但是其实质是不一样的。这里简单地分析一下 vue 的组件事件监听的原理。 // 假设这是父组件实例 const parentCompIns = &#123; onChildCry() &#123; // do something &#125;, &#125;; // 假设这是子组件的实例 const childCompIns = &#123; listeners: &#123; // 父组件添加子组件监听事件时，其实是在子组件中新增一个事件和处理器的映射 // !注意⚠️，这里只是粗浅的原理分析，并不是vue的真实情况 // !vue会保护handler的执行上下文 cry: () => parentCompIns.onChildCry(), &#125;, mounted() &#123; // 抛出事件 this.$emit(\"cry\"); &#125;, $emit(eventName) &#123; // 检索事件，如果注册了则执行，否则忽略 const handler = this.listeners[eventName]; typeof handler === \"function\" &amp;&amp; handler(); &#125;, &#125;; 方式三：vuex 状态管理器状态管理器 vuex 也可以实现组件间的通讯，而且这是一个非常好的代码解藕的途径。vuex 的实现原理应该是围绕着两个核心概念，分别是数据中心和通知。这里不会详细讨论 vuex 的使用，后面会单独开一篇文章来记录。 方式四：$refs 调用组件实例方法vue 中可以通过 $refs 获取一个组件的实例，然后可以通过实例调用实例方法实现组件间的通讯。 &lt;template> &lt;ChildComp ref=\"childComp\" /> &lt;/template> &lt;script> export default &#123; // ... mounted() &#123; this.$refs.childComp.doSomething(...args); &#125;, &#125;; &lt;/script> 方式五：事件总线 EventBus事件总线是一种解决两个“东西”之间的通讯的方案，这不是 vue 独有的。我不知道其他语言或者平台的事件总线会有什么实现的差别，而 vue 中 EventBus 可以通过订阅发布的设计模式进行实现。 function EventBus() &#123; const _listeners = []; this.$on = function (eventName, handler) &#123; // validate 做入参的判断，eventName是字符串，handler为function // 生成监听器的id，可用于移除操作 const id = Math.random(); // 注册事件 _listeners.push(&#123; id, eventName, // 维护handler的执行上下文 handler: (...args) => handler(...args), &#125;); return id; &#125;; this.$emit = function (eventName, ...args) &#123; // do validating _listeners .filter((item) => item.eventName === eventName) .forEach((&#123; handler &#125;) => handler(...args)); &#125;; this.$off = function (id) &#123; // 移除操作 &#125;; // ... &#125; 以上便是一个基本的事件总线的实现，这个 EventBus 就是一个事件和消息的处理网关，通过网关实例可以订阅指定的事件和发布指定事件消息，EventBus 负责登记和分发消息，这便是订阅发布的设计模式。所以我也称 EventBus 为事件驿站（只是个人的看法）。 至于如何使用 EventBus。我们可以先实例一个 EventBus，把它挂载在全局 window 对象下，或者挂载在 Vue 的原型上都是可以的，又或者通过模块导出一个实例。 Vue.prototype.eventBus = new EventBus(); 组件可以通过如此使用。注意，使用 EventBus 时，需要注意在组件销毁的时候一定要卸载监听器，否则有可能造成内存泄漏。 &lt;template> &lt;!-- 组件一，省略内容 --> &lt;/template> &lt;script> export default &#123; // ... mounted() &#123; // 缓存监听器id this.listener = this.eventBus.$on(\"customEvent\", function () &#123; // do something &#125;); &#125;, destroy() &#123; // 记得卸载监听器 this.eventBus.$off(this.listener); &#125;, &#125;; &lt;/script> &lt;template> &lt;!-- 组件二，省略内容 --> &lt;/template> &lt;script> export default &#123; // ... mounted() &#123; // 发布消息 this.eventBus.$emit(\"customEvent\"); &#125;, &#125;; &lt;/script> EventBus 也是一种代码解藕的途径，但是这种方式一般在实际开发的项目中不太推荐采用，不推荐的原因有： 可追溯性和可读性差； 需要卸载监听器，否则一直占用资源，严重还会造成内存泄漏； 所以，EventBus 应该被视作一种保留方案，通常那些不好通过状态管理器 vuex 实现，或者组件间跨度太大的情况下才考虑使用 EventBus。 方式六：全局数据其实这里说的全局数据的方式在上述的方法中也有体现，比如 vuex 或者事件总线都有体现全局数据，只是后两者会更复杂而且具备一定的通知机制。而这里说到的全局数据更简单粗暴一点，我们可以把一个对象挂载在全局 window 下，或者挂载在 Vue 的原型上，又或者通过模块导出，然后各个组件就可以访问到这个对象下的数据了。 总结好了，以上便是关于组件间通讯方式的研究结果。","categories":[],"tags":[{"name":"vue,学习笔记","slug":"vue-学习笔记","permalink":"http://example.com/tags/vue-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"v-show 与 v-if的区别","slug":"v-show-与-v-if的区别","date":"2017-09-13T02:15:20.000Z","updated":"2022-04-13T03:16:27.186Z","comments":true,"path":"2017/09/13/v-show-与-v-if的区别/","link":"","permalink":"http://example.com/2017/09/13/v-show-%E4%B8%8E-v-if%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"在 vue 中，v-show和v-if都是用来控制元素或组件的显示和隐藏，但是它们的显示和隐藏的实现机制有着根本性的差别。 v-show是通过控制 dom 元素的样式display: none的动态添加和去除来实现元素的显示和隐藏的。 而v-if则是通过操作 dom 元素的创建，插入和移除来实现的。一般情况下通过v-if来控制组件的显示和隐藏会进行组件的创建，挂载和销毁，也就是说，v-if的变化会触发组件的生命周期钩子，但是如果通过keep-alive包裹起来，则不会触发创建，挂载和销毁，但是会触发激活钩子activated，即便如此，v-if的元素或组件的显示和隐藏都是通过 dom 操作实现的。 如果明白以上的原理，那么就可以分析它们的优缺点和适用场景。 v-show的优点就是在切换显示隐藏这个动作上效率高，性能好，切占用资源少，因为 dom 元素一直都存在，只是简单修改样式而已。 但是在首次页面渲染的时候，针对那些内容很多的元素，或者很复杂的组件，它们不要求立刻显示，但是仅通过v-show来控制隐藏的话，它们在页面渲染时还是会挂载在页面上的，这就造成了不必要的资源浪费，这也是v-show的一个明显缺点。 v-show的优缺点都是围绕着“dom 元素会存在于文档流中”这一个实际去分析的。针对一些 SSR 的项目，如果要求用户登录之后才能看到某些敏感内容，比如一些资源的下载链接，这个时候用v-show就起不到资源保护的作用，这又是v-show的另外一个缺点。 而以上两个关于v-show的缺点，通过使用v-if都能非常好的得到解决。我认为v-if的一个最重要的优点就是它能够实现异步组件的功能，这能够非常好的防止资源浪费。 但是，v-if的显示和隐藏切换的性能是比不过v-show的，即便通过keep-alive来缓存组件状态和数据。 根据以上的分析可知它们的适用场景。 v-show的适用场景： 需要频繁切换显示和隐藏的元素或组件； 规模比较小的组件或者元素的显示隐藏控制； v-if的适用场景： 无需频繁切换显示隐藏的元素或组件； 异步组件； 资源保护； 每次显示和隐藏都有触发生命周期钩子的需求；","categories":[],"tags":[{"name":"vue,学习笔记","slug":"vue-学习笔记","permalink":"http://example.com/tags/vue-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"vue组件生命周期的表现研究","slug":"vue组件生命周期","date":"2017-09-10T03:40:51.000Z","updated":"2022-04-15T06:27:29.410Z","comments":true,"path":"2017/09/10/vue组件生命周期/","link":"","permalink":"http://example.com/2017/09/10/vue%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"要了解透彻 vue 组件生命周期中每一个阶段做了什么工作，这不是一件简单的事情，这其中可能需要了解 vue 的底层原理，才能明白每一个阶段做了什么工作和为什么需要做这些工作。暂时还没有到研究 vue 底层原理的地步，所以本篇文章仅仅是分析组件或嵌套组件的一些情况。 要了解生命周期就肯定得知道生命周期钩子函数。所谓钩子函数其实际就是一个函数，而“钩子”的表意是该函数与某一个事物或者动作挂钩，当这个事物或动作发生指定的情况，与之连接的“钩子”就会被牵动，从而触发函数的执行。这里的表现与 dom 元素的事件监听非常相似，事实上无论是 dom 元素事件监听还是 vue 生命周期钩子都是一种订阅发布的设计模式。 这里就不展开订阅发布设计模式的说明了，我们只需要知道，vue 生命周期钩子函数会在生命周期的某一刻被 vue 内部逻辑执行。 这里实现一个超超超简单的例子。 // 定义一个组件实例 const vueComp = &#123; created() &#123; console.log(\"vueComp is created.\"); &#125;, mounted() &#123; console.log(\"vueComp is mounted\"); &#125;, &#125;; renderComp(vueComp); // 假设这是一个vue的组件创建逻辑 function renderComp(compConfig) &#123; // created前准备 // 完成创建后，手动拉一下钩子 compConfig.created(); // mounted前准备 // 完成挂载后，手动拉一下钩子 compConfig.mounted(); &#125; 以上就是最根本的钩子函数的执行过程，当然 vue 的组件创建和挂载渲染流程肯定会复杂很多，但是道理应该是相似的。 那么 vue 有哪些生命周期钩子呢？ beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed 另外还有两个虽然不在官方的生命周期图中，但是我认为它们也是生命周期的一环，它们是： activated deactivated 注意，activated 和 deactivated 只有在 keep-alive 包裹下的组件中才会被触发，否则不会被触发，它们有点类似onShow 和 onHide的意思。因为 keep-alive 包裹下的组件是会被缓存起来的，创建和挂载的相关钩子只会被触发一次，而 activated 和 deactivated 分别在每一次的显示和隐藏的时候都会被触发，所以某些初始化和复位的操作可以在这两个钩子函数中处理。 在一个完整的生命周期中组件的钩子函数的执行顺序是这样的： deactivated | | beforeCreate -&gt; created -&gt; beforeMount -&gt; mounted -&gt; activated --------&gt; beforeDestroy -&gt; destroyed | | beforeUpdate -&gt; updated 目前阶段，值得研究的应该是更新的钩子函数。在 vue 的机制中，beforeUpdate 和 updated 只有在组件挂载完成后，即mounted被执行后，该组件的 data 数据发生变化并且驱动视图变化才会触发这两个钩子函数，如果仅仅是 data 数据发生变化，但是不影响视图，那么这两个钩子是不会被触发的。 或者直接通过 dom 操作来改变视图，这也不会触发更新的钩子函数，因为这种行为是脱离了 vue 的生命周期控制的。 另外，还有一点很重要，那就是组件的更新和渲染是异步的。关于异步又会牵扯出一大堆关于事件循环和执行栈的知识，这里暂不研究，实际上我还不是很了解。我们暂时只理解为，vue 会把所有同步操作执行完成后，关于 data 数据的修改会被整合成一次操作，最后再去更新视图，然后触发更新的钩子函数。 简单的写一个例子： const data = &#123; count: 0, &#125;; data.count++; data.count++; data.count++; setTimeout(() => &#123; console.log(data.count); // 打印结果：5 // render view and exec updatedHook function &#125;, 0); data.count++; data.count++; 以上例子可以很初步的了解到异步渲染的原理。目前关于 vue 组件的更新钩子函数我们暂时掌握到这里，等后续深入 vue 原理的时候再补充内容。 而其他的钩子函数，我们主要留意一下几点应该没什么问题了。 在 created 或者 beforeCreate 中做一些早期的初始化工作； 在 mounted 钩子函数中可以做 dom 操作； 在 destroyed 或者 beforeDestroy 中释放资源； 在 beforeCreate 中无法读取 this 对象； 分析完一个组件的生命周期，我们来分析一下组件嵌套的情况下，父子组件的生命周期钩子函数的执行顺序。我们先写一个例子。 App.vue &lt;template> &lt;div id=\"app\"> &lt;button @click=\"toggleChildCompVisible\">Toggle&lt;/button> &lt;button @click=\"changeCount\">Change count&lt;/button> &lt;button @click=\"changeCount2\">Change count2&lt;/button> &lt;button @click=\"changeCount3\">Change count3&lt;/button> &lt;button @click=\"changeCountTroughRefMethod\">Change count4&lt;/button> &lt;ParentComp ref=\"parentComp\" v-if=\"isShow\" :count=\"count\" :count2=\"count2\" :count3=\"count3\" /> &lt;/div> &lt;/template> &lt;script> import ParentComp from \"./components/ParentComp\"; export default &#123; name: \"App\", components: &#123; ParentComp, &#125;, data() &#123; return &#123; isShow: true, count: 0, count2: 0, count3: 0, count4: 0, &#125;; &#125;, methods: &#123; toggleChildCompVisible() &#123; this.isShow = !this.isShow; &#125;, changeCount() &#123; this.count++; &#125;, changeCount2() &#123; this.count2++; &#125;, changeCount3() &#123; this.count3++; &#125;, changeCountTroughRefMethod() &#123; this.count4++; this.$refs.parentComp.changeCount(this.count4); &#125;, &#125;, &#125;; &lt;/script> /components/ParentComp.vue &lt;template> &lt;div> ParentComp &lt;ChildComp ref=\"childComp\" :count=\"count\" :count2=\"count2\" /> &lt;/div> &lt;/template> &lt;script> import ChildComp from \"./ChildComp\"; export default &#123; name: \"ParentComp\", components: &#123; ChildComp, &#125;, props: &#123; count: &#123; type: Number, &#125;, count2: &#123; type: Number, &#125;, count3: &#123; type: Number, &#125;, &#125;, beforeCreate() &#123; console.log(\"ParentComp beforeCreate\"); &#125;, created() &#123; console.log(\"ParentComp created\"); &#125;, beforeMount() &#123; console.log(\"ParentComp beforeMount\"); &#125;, mounted() &#123; console.log(\"ParentComp mounted\"); &#125;, beforeUpdate() &#123; console.log(\"ParentComp beforeUpdate\"); &#125;, updated() &#123; console.log(\"ParentComp updated\"); &#125;, activated() &#123; console.log(\"ParentComp activated\"); &#125;, deactivated() &#123; console.log(\"ParentComp deactivated\"); &#125;, beforeDestroy() &#123; console.log(\"ParentComp beforeDestroy\"); &#125;, destroyed() &#123; console.log(\"ParentComp destroyed\"); &#125;, methods: &#123; changeCount(num) &#123; this.$refs.childComp.changeCount(num); &#125;, &#125;, &#125;; &lt;/script> /components/ChildComp.vue &lt;template> &lt;div>ChildComp&#123;&#123; count &#125;&#125; &#123;&#123; count4 &#125;&#125;&lt;/div> &lt;/template> &lt;script> export default &#123; name: \"ChildComp\", props: &#123; count: &#123; type: Number, &#125;, count2: &#123; type: Number, &#125;, &#125;, data() &#123; return &#123; count4: 0, &#125;; &#125;, beforeCreate() &#123; console.log(\"ChildComp beforeCreate\"); &#125;, created() &#123; console.log(\"ChildComp created\"); &#125;, beforeMount() &#123; console.log(\"ChildComp beforeMount\"); &#125;, mounted() &#123; console.log(\"ChildComp mounted\"); &#125;, beforeUpdate() &#123; console.log(\"ChildComp beforeUpdate\"); &#125;, updated() &#123; console.log(\"ChildComp updated\"); &#125;, activated() &#123; console.log(\"ChildComp activated\"); &#125;, deactivated() &#123; console.log(\"ChildComp deactivated\"); &#125;, beforeDestroy() &#123; console.log(\"ChildComp beforeDestroy\"); &#125;, destroyed() &#123; console.log(\"ChildComp destroyed\"); &#125;, methods: &#123; changeCount(num) &#123; this.count4 = num; &#125;, &#125;, &#125;; &lt;/script> 页面初次渲染的时候能够获得以下日志： ParentComp beforeCreate ParentComp created ParentComp beforeMount ChildComp beforeCreate ChildComp created ChildComp beforeMount ChildComp mounted ParentComp mounted 点击 Toggle 按钮后隐藏组件后，能够获得以下日志： ParentComp beforeDestroy ChildComp beforeDestroy ChildComp destroyed ParentComp destroyed 如果考虑 keep-alive 的话，ChildComp activated 和 ParentComp activated 会依次在 ParentComp mounted 后执行。而隐藏组件的话，并不会销毁组件，所以日志如下： ChildComp deactivated ParentComp deactivated 然后验证了关于更新钩子的一些情况，分别依次点击按钮 Change count，Change count2，Change count3，Change count4，能够获得已下日志： Change count： ParentComp beforeUpdate ChildComp beforeUpdate ChildComp updated ParentComp updated Change count2： ParentComp beforeUpdate ParentComp updated 点击 Change count3 没有任何日志产生。 Change count4： ChildComp beforeUpdate ChildComp updated 分析可以得出以下结论： 按钮 123 三个测试可以分析出，父组件的 data 和 props 发生变化后，不一定就会触发本组件的更新，按照上文的更新钩子函数的分析，需要引起视图变化才会触发更新钩子函数，还有一种情况就是，把变化的属性传入到子组件中，即便子组件并没有引起视图变化，但是在父组件的角度来看，子组件是视图的一部分，而此时子组件的属性确实发生了变化，所以父组件依旧会触发更新的钩子函数，否则其他情况不会触发更新钩子； 按钮 4 得出的结论，子组件的更新并不一定会触发父组件的更新钩子函数，还是那个道理，模型+视图变化才会触发更新钩子； 以上就是本篇文章关于 vue 组件的生命周期的所有研究。关于“每个生命周期 vue 内部做了什么工作”，这需要深入 vue 的源码研究，往后会另开一文来记录。此外还有 mixin 的情况分析，这也会新起一篇文章来记录。","categories":[],"tags":[{"name":"vue,学习笔记","slug":"vue-学习笔记","permalink":"http://example.com/tags/vue-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"为什么vue中的data必须是一个函数?","slug":"为什么vue中的data必须是一个函数","date":"2017-07-20T09:30:11.000Z","updated":"2022-04-15T10:22:15.107Z","comments":true,"path":"2017/07/20/为什么vue中的data必须是一个函数/","link":"","permalink":"http://example.com/2017/07/20/%E4%B8%BA%E4%BB%80%E4%B9%88vue%E4%B8%AD%E7%9A%84data%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0/","excerpt":"","text":"我们在写 vue 的时候经常会写到这样的代码： &lt;script> export default &#123; // ... data() &#123; return &#123; // properties &#125;; &#125;, &#125;; &lt;/script> 对于这样使用 data，我们基本已经习以为常了，以至于到了理所当然的地步了。然后今天无聊去翻看了官方文档，正好看到关于 data 必须是一个函数的说明，那么我今天就研究一下“为什么 data 会被设计成一个函数”。 官方的说明是，如果 Vue 没有这条规则，所有此组件的所有实例的 data 都会相互干扰。 其实看到这里答案已经呼之欲出了，无非就是与引用类型数据（堆）有关。而 data 定义为函数，就是为了防止所有组件实例公用一个引用地址。每次调用 data 函数，都会返回一个新的对象，这样就避免影响其他组件实例。 然而做到实现这一步，并非一定要将 data 定义为函数，其实可以通过对象克隆的方式实现的。这是一个可行方案，但是相对函数的方式，这不是一个可取的方案，因为克隆对象的性能远没有函数生成一个新对象好。 所以，vue 把 data 设计成一个函数。 答案出来的太快了，那么我们再研究一下使用 data 时需要注意什么？ 我们都知道 vue 是一个 MVVM 的框架，data 中的数据都是响应式的，当 data 中的属性发生变化时，就可能会触发视图的变化。 为什么 data 中的属性发生变化会被监听到呢？其实这里就是 vue 的响应式原理。老规矩，这里我们暂时不做过深的分析，后面会新开一篇文章记录。 目前我们可理解为，vue 会对 data 函数返回的对象的所有属性进行递归遍历，给每个属性安装了代理，代理会负责更新数据，并且在更新后把更新的消息抛出去。 分析到这里，我们就知道 data 返回的对象会被 vue 递归遍历，一看到递归，我们就要很自然的联想到性能问题。如果 data 返回的对象很大，而且嵌套内容很多，这是非常消耗性能的。 所以，我们在实际开发中，应该考虑这样使用 data： 仅在 data 中返回与视图相关的数据； 避免 data 中出现无用的嵌套数据； 有嵌套数据时，我们应该想方法打平它们； 好了，以上便是这篇文章所有的内容。","categories":[{"name":"理性","slug":"理性","permalink":"http://example.com/categories/%E7%90%86%E6%80%A7/"}],"tags":[{"name":"vue,学习笔记","slug":"vue-学习笔记","permalink":"http://example.com/tags/vue-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}],"categories":[{"name":"理性","slug":"理性","permalink":"http://example.com/categories/%E7%90%86%E6%80%A7/"},{"name":"感性","slug":"感性","permalink":"http://example.com/categories/%E6%84%9F%E6%80%A7/"}],"tags":[{"name":"学习,开源,成长","slug":"学习-开源-成长","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0-%E5%BC%80%E6%BA%90-%E6%88%90%E9%95%BF/"},{"name":"项目经历,webpack","slug":"项目经历-webpack","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86-webpack/"},{"name":"Javascript,Promise","slug":"Javascript-Promise","permalink":"http://example.com/tags/Javascript-Promise/"},{"name":"情感,观后感","slug":"情感-观后感","permalink":"http://example.com/tags/%E6%83%85%E6%84%9F-%E8%A7%82%E5%90%8E%E6%84%9F/"},{"name":"javascript,大犀牛学习日记","slug":"javascript-大犀牛学习日记","permalink":"http://example.com/tags/javascript-%E5%A4%A7%E7%8A%80%E7%89%9B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"vue,学习笔记","slug":"vue-学习笔记","permalink":"http://example.com/tags/vue-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}